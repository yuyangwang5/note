## The Community-search Problem and How to Plan a Successful Cocktail Party 2010

### 问题定义

#### Problem 1 (Generic objective function:) 
给无向完全图$G=(V,E)$，查询点集$Q \subseteq V$，优良度评价函数$f$(goodness function)，找到一个诱导子图$H=(V_H, E_H)$，使得：  
(i) $V_H$ 属于$Q(Q\subseteq V_H)$；  
(ii) $H$ 连通；  
(iii) $f(H)$在所有可行的$H$选择中最大。

在本文中，将关注$f_m$，$f_m(H)$表示$H$中所有节点度数的最小值，它有助于防止并入离$Q$很远的社区。

另一种防止并入离查询节点很远的社区的方法，为设置距离约束。  
设$d_G(v,q)$ 为$G$中$d$与$q$最短路径的距离。则  
$D_Q(G, v) = \sum_{q\in Q} d_G(v,q)^2$，用节点v离Q中所有查询节点的距离的平方和表示v到Q的距离；  
$D_Q(G) = max_{v\in V(G)}\{D_Q(G, v)\}$，用最大的v到Q距离值作为图的一个距离属性。  

由此，可以定义第二类问题：
#### Problem 2
给无向完全图$G=(V,E)$，查询点集$Q \subseteq V$，距离限制参数$d$，找到一个诱导子图$H=(V_H, E_H)$，使得：  
(i) $V_H$ 属于$Q(Q\subseteq V_H)$；  
(ii) $H$ 连通；  
(iii) $D_Q(H) \le d$；  
(iv) $f_m(H)$在所有可行的$H$选择中最大。

### 无大小约束的社区
在该阶段将不考虑社区大小约束，即下面提及问题2，拿掉约束$D_Q(H) \le d$。

最开始，先提出一个解决Problem 2的算法，此处命名为Greedy。该算法步骤为：  
1. 设$G_0 = G$为输入的图。之后每一步都会删除$G_0$中的一个节点。
2. 设$u$为$G_{t-1}$中拥有最小度数的节点；
3. 在第t步中，删掉$G_{t-1}$中u和与u临接的边，获得$G_t$；
4. 若 (i) 查询点集Q中有一个节点成为了度数最小节点 或 (ii) 从$G_{t-1}$去除点后Q不再连通，则在第t步停止，返回$G_{t-1}$。

实现此算法时，可以使用一个表来存储节点。该表行数等于图中所有节点中的最大读书，行号代表节点，相同度数的节点存储于同一行，同时拥有参数(设为$d_{min}$)实时更新度数最小节点所在的行。删除u时，u的邻居节点由d行移到d-1行。由该过程可知$d_{min}$最多会往行号减小的方向移动一格。

Theorem 1 设G为图，Q为查询点集，算法Greedy返回的为问题2的最优解。

PROOF. 设$G_O$为该问题的最优解。假设在GREEDY的第t步$G_O$中第一次有点（设为v）被选择（要消除）。由于$G_O$中第一次有节点被选，也就是说从G到$G_t$所删掉的所有节点并没有出现于$G_O$中，即$G_O$为$G_T$的子图。由此，在$G_t$中，一定有个连通分量（设为$G_{t}^{'}$），其为$G_O$的超图（supergraph）。由此，因为在$G_t$和$G_O$中，v均为度数最小的节点，而v仅可能与$G_{t}^{'}$上的点相连，所以有$\delta_{G_{t}^{'}}(v) \ge \delta_{G_{O}}(v)$。此时，$G_{t}^{'}$就拥有最优的最小度数属性。  
(欠缺的证明：v为Q中节点或删去v后，$G_{t}^{'}$的Q不连通)

实际上，对于$f$，可以推广到任意单调函数，Greedy都能寻找到关于Problem 2的最优解。

**Definition 1**（单调函数）  
设V为一组节点，$\mathcal{G}_V$是所有可以在V上定义的图的集合（图的点一定为V），$f$是以$\mathcal{G}_V$的图为输入、分数为输出的一个函数，即$f:\mathcal{G}_V \rightarrow \mathbb{R}$。则$f$为单调函数当且仅当对于每个G，任何G的导出子图H（不是点导出子图，H拥有和G一样的点集），均有：$f(H) \le f(G)$ 或 $f(H) \ge f(G)$。

**Definition 2**（节点单调函数）  
设$\mathcal{G}_V$定义同 Definition 1，$f$以$\mathcal{G}_V$的图和V上任意一个点的为输入、输出分数，即$f:\mathcal{G}_V \times V \rightarrow \mathbb{R}$。则$f$为单调函数当且仅当对于每个G，任何G的导出子图H，且任何H中的节点v，均有：$f(H,v) \le f(G,v)$ 或 $f(H,v) \ge f(G,v)$。

对于某种性质（如图是否为二分图），我们可以用布尔函数函数，如$f(G) = 1$则G属于二分图，$f(G) = 0$则G不属于。

对于图的一些测量值，有：  
**Example 1** (Degree) 设 d(G,v)表示节点的度数，该函数节点单调。  
**Example 2** (Minimum degree) 设 $f_m(G)$表示图中最小度节点的度数，该函数节点单调。（想象往H增边的过程，该过程点集不变）  
**Example 3** (Distance) 设 $D_Q(G,v)和D_Q(G)$定义为之前所定义的距离，它们分别为节点单调函数、单调函数。

**Definition 3** 设$f:\mathcal{G}_V \times V \rightarrow \mathbb{R}$，G最大化f 当且仅当 $min_{v\in V(G)} {f(G,v)} \ge min_{v\in V(H)} {f(H,v)}$ 

现在定义一个一般化的社区搜索问题

**Problem 3** （鸡尾酒派对，Cocktail party）$G=(V,E)$为无向图，$f:\mathcal{G}_V \times V \rightarrow \mathbb{R}$为节点非递增函数，$f_1, f_2, ..., f_k$为非递增属性。希望找到H，最大化$f$的同时满足$f_1, f_2, ..., f_k$。

为了解决问题3，可以对Greedy算法进行推广，称为GREEDYGEN：  
1. 从$G_0 = G$开始
2. 查找是否有v，它会破坏某个属性条件，如果有，则删去该点及其所有邻居；否则，寻找所有节点中使$f(G,v)$的，把它删去。
3. 不断重复步骤2。不断迭代直到所有节点都删除。
4. 每一步记录图的分数，将分数最大的图返回。

**Theorem 2** GREEDYGEN返回的图为问题3最优解。

### 有大小约束的社区
上一步算法的缺点是可能返回很大的子图。但若要设置距离约束，该算法为NP-hard难题。

**Problem 4** (Minimum degree with upper bound on the size) $G=(V_G,E_G)$为无向图，$Q\Subset V$为查询节点，d为距离限制参数，k为大小限制参数。希望找到子图$H = (V_H, E_H)$，使得：  
(i) H 包含 Q；  
(ii) H连通；  
(iii) $D_Q(H) \le d$；
(iv) $|V_H| \le k$；
(v) H拥有最大的最小节点。

**Theorem 3** 问题4是 NP-hard难题。  
PROOF. 现在希望将问题4规约到具有单位权重的斯坦纳树问题。该问题为NP-hard问题，其决策问题（Decision Problem）是，给定$G=(V,E)$，一组节点$T (T \subset V)$和一个整数k。要求找到G的一个子树，其包含T所有节点，且最多具有k条边。

现定义问题4的决策版本：给定G，查询节点为T，节点数目上限是k+1，距离约束无限大，此时要找的图最小度至少为1。现在论证如果提坦纳树问题有解，我们问题也有，反之亦然。

一方面，任何最多使用k条边的斯坦纳树也是我们问题的一个解（即斯坦纳问题有解，我们的问题肯定也有解），k条边最多使用k+1个节点，符合大小约束。另一方面，对于问题4的解H，其最多包含k+1个节点，只要获取H的任意生成树，其即为斯坦纳树问题的解。

可以看出，即使去掉距离约束，问题也是NP-hard。

在此处，会介绍两种启发式算法，寻找大小受限的社区。分别为GreedyDist和GreedyFast，前者着重优化质量，后者则是速度。

#### GreedyDist
对于距离界限d，设$f(G)=1$当G符合距离节点，可得$f(G) \ge f(H)$。其为一个布尔函数，可把距离界限看作图的属性。GreedyDist使用GreedyGen作为子程序，把距离界限作为属性之一。若GreedyGen返回的图不符合需求，则采用更严格的距离界限，直到大小满足约束 或 查询节点不再连通。对于后者，返回的图则为所有返回的图中最小的图。

对d的范围调整也可以采用二分法进行查找以加快速度。

#### GreedyFast
该算法对图进行预处理，使得输入的图被限制在距离查询节点最近的$k^{'}$个节点内；$k^{'}$定义为使得结果连通且包含至少k个节点的最小值（没有说k如何寻找，猜测也是使用二分法）。

算法会在预处理的图上进行GreedyGen。若忽略距离约束，算法可以更快。


