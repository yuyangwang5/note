## From Louvain to Leiden: guaranteeing well-connected communities 2018

### 社区质量函数

#### 模块度，Modularity
该方法尝试将社区内实际边数和预期边数（假设边随机均匀生成）之间的差距最大化。设$e_c$表示社区c中的边数，$\frac{K_{c}^{2}}{2m}$表示预期的边数，其中$\K_{c}^{2}$表示社区c中的节点度数之和，m表示网络中的边数。由此，模块度的公式为：

$$\mathcal{H} = \frac{1}{2m} \sum_c(e_c - \gamma \frac{K_{c}^{2}}{2m})$$

$\gamma \ge 0$是一个分辨率参数，高分辨率会有更多社区，低分辨率则相反。

#### CPM, Constant Potts Model
CPM函数定义为：

$$\mathcal{H} = \sum_c(e_c - \gamma 
\left(
    \begin{matrix}
    n_c \\
    2
    \end{matrix}
\right)
)$$

其中$n_c$表示社区c中的节点数。分辨率参数$\gamma$在该公式中有直观的解释：社区内部的密度应不少于$\gamma$，而社区间应低于$\gamma$。更高的$\gamma$会带来更多社区，低则相反。

### Louvain
该算法通过两个基本阶段来优化质量函数：  
1. 节点的局部移动；
2. 网络的聚合。
   
在局部移动阶段，单个节点被移动到能使质量函数增加到最大的社区中；在聚合阶段，将会根据第一阶段的结果对网络进行分区，之后每个分区视为一个节点，由此可以看成一个新的网络。  
这两个阶段不断重复，直到任何局部移动都无法增加质量函数。  
该算法流程可用下图表示：

![example of louvain](./Leiden_pic/1%20example%20of%20louvain.png "example of louvain")

一般，最开始时每个节点看成一个社区。不过也可以用不同分区方式进行初始化。如，在尝试找更好的分区时，可以先执行算法，进行多次迭代，使用其中一个迭代所识别的分区进行初始化。

然而Louvain有个缺点：找到的分区可能内部连接性很差，甚至会识别出内部断开的社区。在实验中，断开的社区还经常出现。不断的迭代，虽然会增加函数质量，但会加剧这种社区内部断裂的问题。在Louvain算法中，一个节点被移动到另一个社区时，这个节点在原社区中，可能是重要的连接节点，如下图所示：
![disconnected community](./Leiden_pic/2%20disconnected%20community.png "disconnected community")

这个问题出在Louvain算法本身，与质量函数无关。若只考虑社区内部断开这种极端表现，无法解决根本问题，需要更进一步考虑。

### Leiden算法
Leiden算法可以保证社区连接良好。它有三个阶段：
1. 节点的局部移动；
2. 分区的细化；
3. 基于细化分区进行网络聚合
   
在进行分区细化时，会使用非细化分区来为聚合的网络创建初始分区。该算法的示意图如下：
![Leiden algorithm](./Leiden_pic/3%20Leiden%20algorithm.png "Leiden algorithm")

在Leiden算法中，细化分区阶段可能会将初始化的分区分成多个子社区，聚合网络是基于细化后的分区创建的。

设细化后分区为$P_{refined}$，细化前为P。通过P得到$P_{refined}$的过程为：
1. 最初，设置$P_{refined}$为：每个节点都是一个分区；
2. 局部合并节点，某个社区中的节点可以被合并到另一个社区；

细化分区阶段，节点不盲目追求质量函数最大化，它能够和任意能够提高质量函数的社区合并，质量函数增益越大，选择该社区的概率就越大。选择社区的随机程度由参数$\theta \ge 0$指定。

Leiden算法和Louvain算法另一个重要区别为局部移动阶段的实现。我们称Leiden对应程序为快速局部移动程序（fast local move procedure）。快速局部移动程序过程如下：
1. 初始化队列，队列以随即顺序添加网络所有节点；
2. 从队列弹出一个元素，查看该节点移到不同社区能否提高质量函数值。若提高，则进行移动（随机方式），且该节点的邻居中，所有不属于新社区且未在队列中的节点也将被添加到队列尾部。
3. 不断重复步骤2，直到队列为空。

如此，Leiden第一次访问网络中所有节点时与Louvain相同。但之后，Leiden仅访问移动了的节点的部分邻居，不像Louvain还要全部访问。在此步骤，Leiden比Louvain更快更有效。

Leiden算法每次迭代后，可以保证：
1. 所有社区都是$\gamma$-分离的；
2. 所有社区都是$\gamma$-连接的；  
   $\gamma$指的是质量函数中的分辨率参数。Louvain算法也保证$\gamma$-分离性质，没有可以合并的社区；但它不能保证$\gamma$-连接。<br>  
   Leiden算法中分区未改变的迭代称为稳定迭代。稳定迭代可以保证：
3. 所有节点都被局部最优分配；
4. 所有社区都是子分区$\gamma$-密集（$\gamma$-dense）  
   Louvain稳定迭代后也保证节点最优性，即没有单个节点可以被移动到新的社区。但Louvain算法不能保证分区的$\gamma$-密集，因为它的分区可能可以被划分为两部分，使得：(1) 两部分彼此连接良好；(2) 任何一部分都没有点可以移动到另一个社区；(3) 每一部分本身也是$\gamma$-密集。  
   子分区$\gamma$-密集不意味单个节点被局部最优分配，它只意味单个节点与其社区连接良好。<br>
    对于Louvain算法，稳定迭代后，后面所有迭代也是稳定的。由此，Louvain算法稳定迭代后，无法进一步改进。而Leiden算法稳定迭代后，在后续迭代仍有可能进一步改进。继续迭代Leiden算法，将使其收敛到一个分区，使得：
5. 所有社区都是均匀$\gamma$-密集（$\gamma$-dense）；
6. 所有社区都是子集最优的。

一个社区若无法进一步分离，那么该社区就是均匀γ-密集。若所有社区都是均匀γ-密集，那么该分区质量离最优不会太远。社区的子集最优表示，没有子集可以移动到不同的社区。其为Leiden算法提供了最强的保证。

上述性质的Louvain与Leiden对比如下图所示：
![Algorithm guarantees](./Leiden_pic/4%20Algorithm%20guarantees.png "Algorithm guarantees")

### 实验分析
论文作者在java上实现了算法，代码于<https://github.com/CWTSLeiden/networkanalys>。

首先看连接不良的社区。对于Louvain算法，实验确认每个分区是否内部有连接在一起。此外，为了分析是否分析的连接是不良连接，还在每个分区后成的子网络上运行了Leiden算法，若可以进一步划分则认为连接不良。连接不良的社区包括断开的社区。

社区不良实验结果如下图所示：
![社区不良实验](./Leiden_pic/6%20社区不良实验.png "社区不良实验")
Leiden算法成功解决了社区不良的问题。

之后我们来研究算法的扩展性。实验通过以下的方式构建网络：
1. 创建指定数量的节点，并将每个节点分配到一个社区，所有社区大小相等；
2. 确定边数，以确定平均度数。
3. 创建边，两点属于不同社区，连线概率为u，同一社区则为1-u。
两种算法进行10次迭代，使用CPM质量函数，分辨率参数值基于u确定，生成从$10^3$到$10^7$节点数的网络。每组参数实验重复10次。分区质量报告定义为$\frac{2H}{m}$，其中H为质量函数的值。

实验结果如下图所示：
![扩展性实验](./Leiden_pic/7%20扩展性实验.png "扩展性实验")

分区质量上，u值较低，分区明确，两者均能正确分区；u值增大，Leiden质量开始优于Louvain算法。

时间上，Leiden算法显然比Louvain算法更快。对于较低的u值，Leiden仅比Louvain快约两；对于较高的u值，Leiden的速度比Louvain快一个数量级：对于最大网络，Leiden的速度比Louvain快10到100倍。

下图展示算法所有迭代运行时间与分区质量的关系：
![迭代运行时间与分区质量的关系](./Leiden_pic/8%20扩展性实验_2.png "迭代运行时间与分区质量的关系")

Louvain很快就达到一个状态，在该状态下其无法寻找到更好的分区，而Leiden则在不断寻找更好的分区。Louvain在后面的迭代很快，这是因为其分区保持不变（除了u=0.2和n=$10^7$）。图6表明，Leiden在计算时间和分区质量方面都优于Louvain。

由于基准网络分析价值有限，所以此处用真实网络进行分析。所使用的真实网络信息如下：
![实验图信息](./Leiden_pic/5%20实验图信息.png "实验图信息")

该图中显示了Louvain和Leiden所获得的最大模块性，分辨参数$\gamma=1$

下图展示两个算法在真实图中第一次迭代的运行时间：
![算法运行时间(真实图)](./Leiden_pic/9%20算法运行时间(真实图).png "算法运行时间(真实图)")

可以看见，Leiden算法在真实网络上也快于Louvain，甚至在某些图上能快10倍以上。
下面展示两个算法在真实图上运行时间与分区质量间的关系，总共迭代10次：
![运行时间-分区质量](./Leiden_pic/10%20运行时间-分区质量.png "运行时间-分区质量")

在该图中可以看见，速度上而言，对于某些图，在Louvain算法完成一次迭代之前，Leiden算法就可以完成10次迭代。质量上看，Leiden算法也优于Louvain。

对于基准网络而言，Leiden算法在几次迭代后就可以收敛；而对于真实网络，Leiden算法可能需要相当多的时间才可以达到第一次稳定迭代。